=======================
 Minmake Hacking Howto
=======================

Introduction
============
This document should get you started if you want to extend minmakes
capabilities or when you want to find bugs (which hopefully won't
exist :-)

The files in the `scripts` directory contain the actual generic code.

Recurse into subdirectories.
============================

The basic trick is, that directories are transformed into phony
prerequisites.  The rule to make such a prerequisite is then, to run a
submake there which uses ``$(MM-sysdir)/descend.include`` as the makefile

``descend.include`` in then includes the generic definitions. first.
This will only contain variable and template definitions, no targets.

Next it includes the actual Makefile in the current
directory (we could name it anyhthing we like, but for convenience we
just use the normal name ``Makefile``).

Then it expands the templates using ``$(foreach)`` and ``$(eval)``
statements that iterate over the magic Variables, and produce the
actual target recipes.

Finally it includes the production rules for directory recursion.



Output generation
=================
For every external command that minmake knows of (i.e compile, link,
etc.) there are actually three versions:

- **cmd_xxx** The actual command to run.
- **quiet_cmd_xxx** The output in quiet mode
- **silent_cmd_xxx** The output in silent mode, supposed to be empty

The functions echo-cmd, echo-cmd-arg and echo-cmd-arg2 are supposed to
be called to generate the command output. Note that even in verbose
mode, the output is produced by a shell echo command, the normal make
output generation is disabled completely for all rules generated by
minmake via templates. This is easier to code and allows to slightly
transform the output: All output is started by two blanks, except
subdir changes which start in the first column.

The various echo-cmd functions only differ in the number of args they
take. Use as much as any of the cmd_xxx or the quiet_cmd_xxx function needs.
The expansion of these functions will end in a semicolon, so they can
directly be followed by the actual commands.

Templates
=========
A Template creates a makefile snippet containing variable
assignments, dependencies and recipes for a single object whose
name is given as the first argument.

Templates govern, how programs, libraries, etc are build. The rules
for object file creation are specified in `generic.include` in the
normal way, as general pattern rules. Those are mostly copied
from make's default, and only adapted to produce quiet output as
explained above.


Various smaller hacks
=====================
To create a new recursive pseudo target foo, just mimick the implementation of
build: make it depend on a prerequisite MM-foo. Then add a double colon
rule for MM-foo that declares a dependency on $(subdirs). This will
start the recursion mechanism.  Using a double colon rule allows you
to add actions individually from every template.

The _build: target in the toplevel Makefile snippet is needed to
provide make with a proper default target, in case make is called
without arguments. It just redirets to the actual build target
defined later.

Both, the call-subdir-make and the ifdef D part in
toplevel-exit.include use the same trick. The problem: even if make is
called with several goal targets, we only want to redirect to a single
make call with the same goals. Also we don't know the given targets,
so we need to allow anything. The solutions: Use a catch all recipe,
that does nothing, but has a phony precondition that has the desired
call as a precondition.
